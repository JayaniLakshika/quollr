---
title: "1. Data preprocessing"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{1. Data preprocessing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE, 
  message = FALSE
)
```

```{r setup}
library(quollr)
library(dplyr)
```

To begin the algorithm, you need to have 2D embedding generated for the training data. Then, you need to preprocess the 2D embedding data to obtain regular hexagons. 

The example discussed in this package is 3-$d$ S-curve data with additional four noise dimensions. UMAP is used as the Non-linear dimension reduction technique and UMAP embeddings are generated for the training S-curve data.

You can pass the generated UMAP embedding data to undergo the preproceesing. The function default `hex_ratio` is set up to obtain regular exagons, but you can change according to what height and width should need to have in obtaining regular hexagons.

```{r}
scaled_umap <- gen_scaled_data(data = s_curve_noise_umap, x = "UMAP1", y = "UMAP2", 
                hex_ratio = NA)

glimpse(scaled_umap)
```
